<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Collectiico — Rotas Interativas</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    #map { height: 520px; min-height: 320px; }
  </style>
</head>
<body class="bg-gray-50 text-gray-800 min-h-screen flex flex-col">

  <header class="bg-amber-700 text-white">
    <div class="max-w-6xl mx-auto px-6 py-4 flex items-center justify-between">
      <h1 class="text-lg font-bold">Collectiico</h1>
      <nav class="flex gap-3">
        <a href="index.html" class="hover:underline">Início</a>
        <a href="solicitar.html" class="hover:underline">Solicitar Coleta</a>
        <a href="cadastro.html" class="hover:underline">Cadastro</a>
        <a href="campanhas.html" class="hover:underline">Campanhas</a>
      </nav>
    </div>
  </header>

  <main class="flex-1 max-w-6xl mx-auto px-6 py-8">
    <h2 class="text-2xl font-bold text-amber-800 mb-2">Rotas interativas</h2>
    <p class="text-gray-600 mb-6">Visualize no mapa as solicitações registradas, gere rotas simuladas e calcule a distância total aproximada. A geocodificação é feita pela API pública Nominatim (OpenStreetMap) e os resultados são cacheados no navegador.</p>

    <div class="grid md:grid-cols-3 gap-6">
      <div class="md:col-span-2 bg-white p-4 rounded shadow">
        <div id="map" class="rounded"></div>
        <div class="mt-3 flex gap-3 items-center">
          <button id="btnLoad" class="bg-amber-700 text-white px-4 py-2 rounded">Carregar solicitações e marcar no mapa</button>
          <button id="btnRoute" class="bg-amber-700 text-white px-4 py-2 rounded">Gerar rota (simular)</button>
          <button id="btnClearCache" class="border px-3 py-2 rounded">Limpar cache de geocoding</button>
          <div id="status" class="text-sm text-gray-600 ml-4"></div>
        </div>
        <div id="infoDistance" class="mt-3 text-sm text-gray-700"></div>
      </div>

      <div class="bg-white p-4 rounded shadow">
        <h3 class="font-semibold mb-3">Paradas (solicitações)</h3>
        <div id="listaRotas" class="space-y-3 text-sm text-gray-700 max-h-[420px] overflow-auto"></div>
      </div>
    </div>
  </main>

  <footer class="bg-amber-900 text-amber-100 py-6 text-center">
    <div class="max-w-6xl mx-auto px-6">Protótipo Collectiico — Rotas Interativas</div>
  </footer>

  <script>
  function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }
  function haversineDistance(a, b){
    const toRad = (v) => v * Math.PI / 180;
    const R = 6371;
    const dLat = toRad(b.lat - a.lat);
    const dLon = toRad(b.lng - a.lng);
    const lat1 = toRad(a.lat);
    const lat2 = toRad(b.lat);
    const sinDLat = Math.sin(dLat/2) * Math.sin(dLat/2);
    const sinDLon = Math.sin(dLon/2) * Math.sin(dLon/2);
    const x = sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon;
    const c = 2 * Math.atan2(Math.sqrt(x), Math.sqrt(1-x));
    return R * c;
  }

  const map = L.map('map', { center: [-20.4697, -54.6201], zoom: 12 });
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19, attribution: '&copy; OpenStreetMap'
  }).addTo(map);

  let markersLayer = L.layerGroup().addTo(map);
  let routeLayer = L.layerGroup().addTo(map);

  const GEOCACHE_KEY = 'collect_geocache';
  const geocache = JSON.parse(localStorage.getItem(GEOCACHE_KEY) || '{}');

  async function geocodeAddress(address){
    const key = address.trim();
    if (!key) return null;
    if (geocache[key]) {
      return geocache[key];
    }
    const q = encodeURIComponent(key);
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${q}&limit=1&addressdetails=0`;
    try {
      await sleep(800);
      const res = await fetch(url, { headers: { 'Accept-Language': 'pt-BR' } });
      if (!res.ok) throw new Error('Erro na requisição de geocoding');
      const data = await res.json();
      if (data && data.length > 0) {
        const item = { lat: Number(data[0].lat), lng: Number(data[0].lon), display_name: data[0].display_name, timestamp: Date.now() };
        geocache[key] = item;
        localStorage.setItem(GEOCACHE_KEY, JSON.stringify(geocache));
        return item;
      } else {
        return null;
      }
    } catch (err) {
      console.error('Geocoding error', err);
      return null;
    }
  }

  document.getElementById('btnClearCache').addEventListener('click', () => {
    if (confirm('Apagar cache de geocoding salvo no navegador?')) {
      localStorage.removeItem(GEOCACHE_KEY);
      alert('Cache limpo.');
    }
  });

  document.getElementById('btnLoad').addEventListener('click', async () => {
    markersLayer.clearLayers();
    routeLayer.clearLayers();
    document.getElementById('infoDistance').textContent = '';
    document.getElementById('status').textContent = 'Carregando solicitações...';

    const coletas = JSON.parse(localStorage.getItem('collect_coletas') || '[]');
    const listaDiv = document.getElementById('listaRotas');
    listaDiv.innerHTML = '';

    if (coletas.length === 0) {
      document.getElementById('status').textContent = 'Nenhuma solicitação encontrada.';
      listaDiv.innerHTML = '<div class="text-sm text-gray-500">Nenhuma solicitação para exibir.</div>';
      return;
    }

    const points = [];
    for (let i = 0; i < coletas.length; i++) {
      const c = coletas[i];
      const endereco = c.endereco || c.address || '';
      const itemDiv = document.createElement('div');
      itemDiv.className = 'p-2 border rounded bg-gray-50';
      itemDiv.innerHTML = `<div class="font-medium">${c.nome} <span class="text-sm text-gray-500">(${c.status || 'agendada'})</span></div>
                           <div class="text-sm text-gray-600">${endereco}</div>
                           <div class="text-sm text-gray-600">Materiais: ${(c.materiais||[]).join(', ')}</div>
                           <div class="text-xs text-gray-500 mt-1" id="geostatus-${c.id}">Verificando coordenadas...</div>`;
      listaDiv.appendChild(itemDiv);

      // if coordinates already saved in the coleta, use them
      if (c.lat && c.lng) {
        points.push({ id: c.id, nome: c.nome, endereco, materiais: c.materiais || [], lat: c.lat, lng: c.lng, display_name: c.localDisplay || endereco });
        document.getElementById(`geostatus-${c.id}`).textContent = 'Coordenadas encontradas no pedido.';
        const m = L.marker([c.lat, c.lng]).addTo(markersLayer);
        m.bindPopup(`<b>${c.nome}</b><br>${endereco}<br><small>Materiais: ${(c.materiais||[]).join(', ')}</small>`);
        continue;
      }

      const ge = await geocodeAddress(endereco);
      const geostatusEl = document.getElementById(`geostatus-${c.id}`);
      if (ge) {
        points.push({ id: c.id, nome: c.nome, endereco, materiais: c.materiais || [], lat: ge.lat, lng: ge.lng, display_name: ge.display_name });
        geostatusEl.textContent = 'Local encontrado: ' + ge.display_name;
        const m = L.marker([ge.lat, ge.lng]).addTo(markersLayer);
        m.bindPopup(`<b>${c.nome}</b><br>${endereco}<br><small>Materiais: ${(c.materiais||[]).join(', ')}</small>`);
      } else {
        geostatusEl.textContent = 'Endereço não localizado (geocoding falhou).';
      }
    }

    if (points.length > 0) {
      const latlngs = points.map(p => [p.lat, p.lng]);
      map.fitBounds(latlngs, { padding: [40, 40] });
      document.getElementById('status').textContent = `Marcadores adicionados: ${points.length} (de ${coletas.length} solicitações).`;
    } else {
      document.getElementById('status').textContent = 'Nenhum ponto geocodificado com sucesso.';
    }

    window.__collect_points = points;
  });

  document.getElementById('btnRoute').addEventListener('click', () => {
    routeLayer.clearLayers();
    document.getElementById('infoDistance').textContent = '';
    const points = window.__collect_points || [];
    if (!points || points.length === 0) {
      alert('Nenhum ponto disponível para gerar rota. Clique em "Carregar solicitações" primeiro e aguarde a geocodificação.');
      return;
    }
    const routeCoords = points.map(p => [p.lat, p.lng]);
    const poly = L.polyline(routeCoords, { color: '#F59E0B', weight: 5, opacity: 0.8 }).addTo(routeLayer);
    map.fitBounds(poly.getBounds(), { padding: [40, 40] });

    points.forEach((p, idx) => {
      const circle = L.circleMarker([p.lat, p.lng], { radius: 12, fillColor: '#92400e', color: '#fff', weight: 2 }).addTo(routeLayer);
      circle.bindTooltip(String(idx+1), { permanent: true, direction: 'center', className: 'text-white font-bold' }).openTooltip();
    });

    let totalKm = 0;
    for (let i=0;i<points.length-1;i++){
      totalKm += haversineDistance({lat: points[i].lat, lng: points[i].lng}, {lat: points[i+1].lat, lng: points[i+1].lng});
    }
    document.getElementById('infoDistance').textContent = `Distância aproximada total (rota simulada): ${totalKm.toFixed(2)} km (soma de segmentos)`;
  });

  </script>
</body>
</html>
